return()
}
# Limitar longitud observaciones
if (!is.null(input$observaciones) && nchar(input$observaciones) > 2000) {
showNotification("Observaciones demasiado largas (máx 2000 caracteres).", type = "error")
return()
}
# Sanitización básica
entrevistador <- trimws(as.character(input$entrevistador_nombre))
medio <- trimws(as.character(input$medio_entrevista))
fecha <- as.character(input$fecha_entrevista)
hora <- trimws(as.character(input$hora_entrevista))
victim_nombre <- trimws(as.character(input$victim_nombre))
victim_edad <- trimws(as.character(input$victim_edad))
victim_ciudad <- trimws(as.character(input$victim_ciudad))
victim_genero <- input$victim_genero
victim_ocupacion <- trimws(as.character(input$victim_ocupacion))
tipo_victimizacion <- input$victim_tipo_victimizacion
medio_extorsion <- trimws(as.character(input$medio_extorsion))
solicitud_dinero <- input$solicitud_dinero
agresor_afirmacion <- trimws(as.character(input$agresor_afirmacion))
denuncia <- input$denuncia
nivel_afectacion <- input$nivel_afectacion
observaciones <- trimws(as.character(input$observaciones))
acompanamiento <- isTRUE(input$acompanamiento)
contacto_futuro <- isTRUE(input$contacto_futuro)
compartir_anonimo <- isTRUE(input$compartir_anonimo)
# Generar ID de caso
case_id <- UUIDgenerate()
# Si se ingresó nombre u otro PII, lo guardamos hashed (SHA-256) para trazabilidad sin exponer identidad
victim_nombre_hashed <- ifelse(nzchar(victim_nombre), digest(victim_nombre, algo = "sha256"), NA)
# Construir documento a insertar
documento <- list(
case_id = case_id,
fecha_registro = Sys.time(),
entrevistador = entrevistador,
medio = medio,
fecha_entrevista = fecha,
hora_entrevista = hora,
# Datos (anonimizados cuando aplica)
victim_nombre_hashed = victim_nombre_hashed,
victim_edad = victim_edad,
victim_ciudad = victim_ciudad,
victim_genero = victim_genero,
victim_ocupacion = victim_ocupacion,
# Contexto
tipo_victimizacion = tipo_victimizacion,
medio_extorsion = medio_extorsion,
solicitud_dinero = solicitud_dinero,
agresor_afirmacion = agresor_afirmacion,
denuncia = denuncia,
nivel_afectacion = nivel_afectacion,
observaciones = observaciones,
# Acciones y autorizaciones
acompanamiento = acompanamiento,
contacto_futuro = contacto_futuro,
compartir_anonimo = compartir_anonimo,
# Metadatos
consentimiento = TRUE,
created_at = Sys.time()
)
# Insertar en MongoDB
mc <- mongo_casos()
if (is.null(mc)) {
showNotification("No hay conexión válida a la colección de casos.", type = "error")
return()
}
tryCatch({
mc$insert(documento)
showModal(modalDialog(
title = "Registro guardado",
paste("Caso registrado correctamente. ID:", case_id),
easyClose = TRUE,
footer = modalButton("Cerrar")
))
# limpiar formulario
updateCheckboxInput(session, "consentimiento", value = FALSE)
updateTextInput(session, "victim_nombre", value = "")
updateTextInput(session, "victim_edad", value = "")
updateTextInput(session, "victim_ciudad", value = "")
updateTextInput(session, "victim_ocupacion", value = "")
updateTextInput(session, "medio_extorsion", value = "")
updateTextInput(session, "agresor_afirmacion", value = "")
updateTextAreaInput(session, "observaciones", value = "")
updateCheckboxInput(session, "acompanamiento", value = FALSE)
updateCheckboxInput(session, "contacto_futuro", value = FALSE)
updateCheckboxInput(session, "compartir_anonimo", value = FALSE)
}, error = function(e) {
showNotification(paste("Error al guardar el caso:", e$message), type = "error")
})
#---- Actualizar el selectInput de bases de datos----
observeEvent(input$bd, {
req(input$bd, mongo_url())
updateSelectInput(session, "coleccion", choices = get_collections(input$bd, mongo_url()))
})
observeEvent(list(input$bd, input$coleccion, mongo_url()), {
req(input$bd, input$coleccion, mongo_url())
#---- Actualizar selects xvar y yvar basados en las columnas----
cols <- tryCatch({
get_columns(input$bd, input$coleccion, mongo_url())
}, error = function(e) {
showNotification("Error al obtener columnas para los selects", type = "error")
return(character(0))  # Vacio para evitar error en updateSelectInput
})
updateSelectInput(session, "xvar", choices = cols)
updateSelectInput(session, "yvar", choices = cols)
#---- Intentar conectar y traer datos----
conexion <- tryCatch({
mongo(collection = input$coleccion, db = input$bd, url = mongo_url())
}, error = function(e) {
showNotification("Error al conectar con MongoDB para cargar datos", type = "error")
return(NULL)
})
if (!is.null(conexion)) {
datos <- tryCatch({
conexion$find('{}')
}, error = function(e) {
showNotification("Error al obtener datos de la colección", type = "error")
return(data.frame())
})
datos_reactivos(datos)
}
})
#---- Actualizar tabla de datos----
output$tablaDatos <- renderDT({
req(datos_reactivos())
datatable(datos_reactivos(), selection = "single")
})
#---- LOGIN CON BASE DE DATOS Y CLUSTER ----
observeEvent(input$login, {
req(input$username, input$password)
# URL del cluster principal (usuarios normales)
url_global <- Sys.getenv("USUARIOS_MONGO_URL")
# Intentar login como administrador (conexión directa)
admin_url <- generate_mongo_url(input$username, input$password)
conexion_admin <- tryCatch(
mongo(collection = "test", url = admin_url),
error = function(e) NULL
)
is_admin_user <- !is.null(conexion_admin) && conexion_admin$count('{}') >= 0
# Conectar a la base de datos de usuarios normales
usuarios_collection <- tryCatch(
mongo(collection = "User", db = "UsuariosApp", url = url_global),
error = function(e) NULL
)
if (is.null(usuarios_collection)) {
showNotification("Error al conectar con la base de datos de usuarios", type = "error")
return()
}
# Buscar usuario por Correo (ojo con la mayúscula)
usuario <- usuarios_collection$find(query = sprintf('{"Correo": "%s"}', input$username))
# Validar usuario normal
is_normal_user <- FALSE
if (nrow(usuario) > 0) {
if (usuario$Contrasena[1] == input$password) {
is_normal_user <- TRUE
}
# --- CASO 1: ADMIN ---
if (is_admin_user) {
user_authenticated(TRUE)
mongo_url(admin_url)
# Crear token JWT
token <- crear_token(input$username, admin_url)
runjs(sprintf("sessionStorage.setItem('jwt', '%s');", token))
# Recargar bases de datos
bases <- get_databases(admin_url)
updateSelectInput(session, "bd", choices = bases, selected = NULL)
shinyjs::hide("loginPanel")
shinyjs::show("app_content")
showNotification(sprintf("Bienvenido administrador: %s", input$username), type = "message")
# --- CASO 2: USUARIO NORMAL ---
} else if (is_normal_user) {
user_authenticated(TRUE)
mongo_url(url_global)
token <- crear_token(input$username, url_global)
runjs(sprintf("sessionStorage.setItem('jwt', '%s');", token))
shinyjs::hide("loginPanel")
show_user_panel_for(input$username)
showNotification(sprintf("Bienvenido, %s", usuario$Nombre[1]), type = "message")
# --- CASO 3: ERROR ---
} else {
showNotification("Usuario o contraseña incorrectos", type = "error")
user_authenticated(FALSE)
}
})
# Enviar al servidor el token guardado en sessionStorage al iniciar la app o refrescar
observe({
# Enviar token del sessionStorage a shiny (se ejecuta siempre que app carga o se refresca)
runjs("Shiny.setInputValue('jwt_token', sessionStorage.getItem('jwt') || '', {priority: 'event'});")
})
#----JWT_TOKEN----
observeEvent(input$jwt_token, {
req(input$jwt_token)
claim <- verificar_token(input$jwt_token)
if (!is.null(claim)) {
user_authenticated(TRUE)
mongo_url(claim$mongo_url)
# Cargar bases y seleccionar bd guardada
bases <- get_databases(claim$mongo_url)
updateSelectInput(session, "bd", choices = bases, selected = claim$bd)
# Delay para cargar colecciones después de que bd se actualice
later::later(function() {
if (!is.null(claim$bd) && claim$bd != "") {
colls <- get_collections(claim$bd, claim$mongo_url)
updateSelectInput(session, "coleccion", choices = colls, selected = claim$coleccion)
}
}, 0.5)
# Luego cargar columnas y actualizar selects xvar, yvar
later::later(function() {
if (!is.null(claim$bd) && !is.null(claim$coleccion) && claim$coleccion != "") {
cols <- get_columns(claim$bd, claim$coleccion, claim$mongo_url)
updateSelectInput(session, "xvar", choices = cols, selected = claim$xvar)
updateSelectInput(session, "yvar", choices = cols, selected = claim$yvar)
}
}, 1)
shinyjs::show("app_content")
shinyjs::hide("loginPanel")
} else {
user_authenticated(FALSE)
runjs("sessionStorage.removeItem('jwt');")
shinyjs::hide("app_content")
shinyjs::show("loginPanel")
}
})
# ---- SINCRONIZAR TOKEN CON SELECCIONES ----
observe({
req(user_authenticated())
# Solo actualizar token si mongo_url y bd existen
if (is.null(mongo_url()) || is.null(input$bd) || input$bd == "") return()
token <- crear_token(
username = NULL,  # Puedes guardar si la guardas en reactive o input
mongo_url = mongo_url(),
bd = input$bd,
coleccion = input$coleccion,
xvar = input$xvar,
yvar = input$yvar
)
runjs(sprintf("sessionStorage.setItem('jwt', '%s');", token))
})
#---- ACTUALIZACIÓN DE COLECCIONES Y COLUMNAS ----
observeEvent(input$bd, {
req(input$bd, mongo_url())
colls <- get_collections(input$bd, mongo_url())
updateSelectInput(session, "coleccion", choices = colls, selected = NULL)
})
# Actualizar columnas cuando cambie la colección
observeEvent(input$coleccion, {
req(input$coleccion, input$bd, mongo_url())
cols <- get_columns(input$bd, input$coleccion, mongo_url())
updateSelectInput(session, "xvar", choices = cols, selected = NULL)
updateSelectInput(session, "yvar", choices = cols, selected = NULL)
# Cargar datos en reactive
conexion <- mongo(collection = input$coleccion, db = input$bd, url = mongo_url())
datos <- conexion$find('{}')
datos_reactivos(datos)
})
#---- Cargar datos cuando cambien bd, coleccion o url----
observeEvent(list(input$bd, input$coleccion, mongo_url()), {
req(input$bd, input$coleccion, mongo_url())
conexion <- tryCatch(mongo(collection = input$coleccion, db = input$bd, url = mongo_url()), error = function(e) NULL)
if (!is.null(conexion)) {
datos <- tryCatch(conexion$find('{}'), error = function(e) data.frame())
datos_reactivos(datos)
}
})
# --- GRÁFICO ---
output$graficoSalida <- renderPlotly({
req(input$coleccion, input$xvar, input$yvar, mongo_url())
conexion <- mongo(collection = input$coleccion, db = input$bd, url = mongo_url())
datos <- conexion$find('{}')
datos_reactivos(datos)
if (!(input$xvar %in% colnames(datos)) || !(input$yvar %in% colnames(datos))) {
return(
plot_ly() %>%
layout(
xaxis = list(visible = FALSE),
yaxis = list(visible = FALSE),
annotations = list(
text = "La magia está sucediendo ✨\n(Verifica tu selección)",
showarrow = FALSE,
font = list(size = 18, color = "grey"),
xref = "paper",
yref = "paper",
x = 0.5,
y = 0.5,
xanchor = "center",
yanchor = "middle"
),
plot_bgcolor = 'rgba(0,0,0,0)',
paper_bgcolor = 'rgba(0,0,0,0)'
)
}
colores_pastel <- c("#AEC6CF", "#FFB347", "#B39EB5", "#77DD77", "#FF6961", "#FDFD96", "#CB99C9", "#FFD1DC", "#CFCFC4")
# Crear vector de colores repetidos según la longitud de datos
colores_asignados <- rep(colores_pastel, length.out = nrow(datos))
p <- plot_ly(datos)
if (input$grafico == "Barras") {
p <- p %>% add_bars(
x = ~.data[[input$xvar]],
y = ~.data[[input$yvar]],
marker = list(color = colores_asignados),
showlegend = FALSE
)
} else if (input$grafico == "Puntos") {
p <- p %>% add_markers(
x = ~.data[[input$xvar]],
y = ~.data[[input$yvar]],
marker = list(color = colores_asignados),
showlegend = FALSE
)
} else if (input$grafico == "Líneas") {
p <- p %>% add_lines(
x = ~.data[[input$xvar]],
y = ~.data[[input$yvar]],
line = list(color = colores_pastel[1]),
showlegend = FALSE
)
} else if (input$grafico == "Histograma") {
p <- plot_ly(
datos,
x = ~.data[[input$xvar]],
type = "histogram",
marker = list(color = "#AEC6CF", line = list(color = "gray", width = 1)),
showlegend = FALSE
)
} else if (input$grafico == "Caja") {
p <- p %>% add_boxplot(
x = ~.data[[input$xvar]],
y = ~.data[[input$yvar]],
marker = list(color = colores_asignados),
showlegend = FALSE
)
}
p %>% layout(
xaxis = list(title = input$xvar),
yaxis = list(title = input$yvar),
title = paste("Gráfico de", input$grafico),
showlegend = FALSE
)
})
#---- Cambiar variables X e Y----
observeEvent(input$swap_axes, {
req(input$xvar, input$yvar)
updateSelectInput(session, "xvar", selected = input$yvar)
updateSelectInput(session, "yvar", selected = input$xvar)
})
#----DESCARGAR EXCEL----
output$descargar_excel <- downloadHandler(
filename = function() {
paste0("datos_", Sys.Date(), ".xlsx")
},
content = function(file) {
req(datos_reactivos())
library(openxlsx)
datos <- datos_reactivos()
# Detectar columnas tipo texto y aplicar saltos de línea
insertar_saltos <- function(x, n = 50) {
vapply(x, function(celda) {
if (is.na(celda)) return("")
gsub(sprintf("(.{%d})", n), "\\1\n", as.character(celda), perl = TRUE)
}, character(1))
}
columnas_texto <- sapply(datos, is.character) | sapply(datos, is.factor)
datos_formateados <- datos  # Copia para modificar solo texto
datos_formateados[, columnas_texto] <- lapply(datos[, columnas_texto, drop = FALSE], insertar_saltos)
wb <- createWorkbook()
addWorksheet(wb, "Datos")
estilo_con_wrap <- createStyle(wrapText = TRUE, valign = "top")
writeData(wb, "Datos", datos_formateados, withFilter = TRUE)
addStyle(wb, "Datos", style = estilo_con_wrap,
rows = 1:(nrow(datos_formateados) + 1),
cols = which(columnas_texto),
gridExpand = TRUE)
setColWidths(wb, "Datos", cols = 1:ncol(datos), widths = "auto")
setRowHeights(wb, "Datos", rows = 1:(nrow(datos) + 1), heights = "auto")
saveWorkbook(wb, file, overwrite = TRUE)
}
)
#----DESCARGAR ZIP----
output$descargar_zip <- downloadHandler(
filename = function() {
paste0("PI_", Sys.Date(), ".zip")
},
content = function(file) {
# Ruta dentro del proyecto (se sube a shinyapps.io o tu servidor)
archivo_origen <- "www/PI.zip"
# Copia el archivo directamente
file.copy(from = archivo_origen, to = file)
}
)
#----CONTRASEÑA OLVIDADA----
# Variable para controlar cooldown
ultima_solicitud <- reactiveVal(Sys.time() - 300)
#---- Mostrar modal para restablecer contraseña----
observeEvent(input$olvide_pass, {
showModal(modalDialog(
title = "Solicitud de restablecimiento",
textInput("usuario_reset", "Ingrese su usuario"),
textInput("correo_user", "Correo de contacto", placeholder = "ejemplo@dominio.com"),
footer = tagList(
modalButton("Cancelar"),
actionButton("enviar_solicitud", "Enviar solicitud")
),
size = "m",
easyClose = TRUE,
fade = TRUE,
style = "border-radius: 15px; padding: 20px; background-color: #f0f8ff;"
))
})
#---- Enviar correo al administrador----
observeEvent(input$enviar_solicitud, {
req(input$usuario_reset, input$correo_user)
# Validar formato de correo simple
if (!grepl(".+@.+\\..+", input$correo_user)) {
shinyalert("Correo inválido", "Por favor ingresa un correo válido al que el administrador pueda contactarte.", type = "error")
return()
}
# Validar cooldown
tiempo_actual <- Sys.time()
if (difftime(tiempo_actual, ultima_solicitud(), units = "secs") < 120) {
shinyalert("Paciencia, por favor", "Ya enviaste una solicitud hace poco. Espera un par de minutos antes de intentar de nuevo.", type = "warning")
return()
}
removeModal()
# Actualizar tiempo de última solicitud
ultima_solicitud(tiempo_actual)
# Cuerpo del correo
cuerpo <- glue::glue("
El usuario **'{input$usuario_reset}'** ha solicitado restablecer su contraseña.\n\n
Comunícate con el usuario al siguiente correo:\n
{input$correo_user}
")
# Crear el mensaje
email <- compose_email(
body = md(cuerpo)
)
# Enviar el correo usando las credenciales guardadas en archivo
tryCatch({
smtp_send(
email,
from = "recupecontrase@gmail.com",        # correo de envío
to = "kecarrilloc@sanmateo.edu.co",       # correo del admin
subject = "Solicitud de restablecimiento de contraseña",
credentials = creds_file("gmail_creds")   # Archivo de credenciales
)
showNotification("Solicitud enviada. El administrador se pondrá en contacto contigo.", type = "message")
}, error = function(e) {
showNotification("Error al enviar la solicitud, por favor, valide usuario y correo", type = "error")
print(e$message)
})
#---- Soporte técnico ----
observeEvent(input$support, {
showModal(modalDialog(
title = tags$strong("Crear/Seguir Ticket"),
easyClose = TRUE,
footer = modalButton("Cerrar"),
size = "m",
tags$div(
style = "line-height: 1.6; font-size: 16px;",
"Para contactar con soporte y crear tickets debe hacer click en el siguiente enlace.",
tags$br(), tags$br(),
"Recuerde, para ingresar al software de tickets debe hacerlo con su usuario y contraseña.",
tags$br(),
"Si no tiene usuario creado en el software de tickets, contacte al administrador por medio del siguiente correo:",
tags$br(), tags$br(),
tags$a(
href = "mailto:rostrosinvisiblessoporte@gmail.com",
"rostrosinvisiblessoporte@gmail.com",
style = "font-weight: bold;"
),
tags$br(), tags$br(),
tags$a(
href = "https://punditic.sd.cloud.invgate.net/portal",
"Abrir portal de soporte",
target = "_blank",
style = "font-size: 18px; color: #007bff; font-weight: bold;"
)
))
})
#---- Cerrar sesión----
#---- Manejar el evento de cierre de sesión----
observeEvent(input$logout, {
shinyalert(
title = "¿Cerrar sesión?",
text = "¿Estás seguro de que deseas cerrar la sesión?",
type = "warning",
showCancelButton = TRUE,
confirmButtonText = "Sí",
cancelButtonText = "No",
callbackR = function(confirm) {
if (confirm) {
# Borra JWT del navegador (sessionStorage + cookie)
runjs("
sessionStorage.removeItem('jwt');
document.cookie = 'jwt=; expires=Thu, 01 Jan 2050 00:00:00 UTC; path=/;';
")
# Limpia estado de la sesión
user_authenticated(FALSE)
# Limpia URL MongoDB y cualquier otro reactive relacionado
try({
mongo_url(NULL)
}, silent = TRUE)
# Oculta el contenido protegido y muestra el login
shinyjs::hide("app_content")
shinyjs::show("loginPanel")
# Opcional: recargar sesión para limpiar completamente y evitar estados residuales
# session$reload()
}
)
})
}
shinyApp(ui, server)
